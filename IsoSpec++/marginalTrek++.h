/*
 *   Copyright (C) 2015-2018 Mateusz Łącki and Michał Startek.
 *
 *   This file is part of IsoSpec.
 *
 *   IsoSpec is free software: you can redistribute it and/or modify
 *   it under the terms of the Simplified ("2-clause") BSD licence.
 *
 *   IsoSpec is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *   You should have received a copy of the Simplified BSD Licence
 *   along with IsoSpec.  If not, see <https://opensource.org/licenses/BSD-2-Clause>.
 */

#pragma once

#include <tuple>
#include <unordered_map>
#include <queue>
#include <atomic>
#include "conf.h"
#include "allocator.h"
#include "operators.h"
#include "summator.h"


namespace IsoSpec
{

Conf initialConfigure(int atomCnt, int isotopeNo, const double* probs);


void printMarginal(const std::tuple<double*,double*,int*,int>& results, int dim);

//! The marginal distribution class (a subisotopologue).
/*!
    This class mostly provides some basic common API for subclasses, but itself is not abstract.
    This class represents the probability distribution generated by one element only -- a subisotopologue.
    For instance, it might be the distribution of C200, that might be part of, say, C200H402.
    It corresponds to the multinomial distribution, where each configuration can also be attributed a precise mass.
    The constructor method perform initial hill-climbing to find the most probable sub-isotopologue (the mode).
*/
class Marginal
{
private:
    bool disowned;
protected:
    const unsigned int isotopeNo;       /*!< The number of isotopes of the given element. */
    const unsigned int atomCnt;         /*!< The number of atoms of the given element. */
    const double* const atom_masses;    /*!< Table of atomic masses of all the isotopeNo isotopes. */
    const double* const atom_lProbs;    /*!< Table of log-probabilities of all the isotopeNo isotopes. */
    const double loggamma_nominator;    /*!< The constant nominator that appears in the expressions for the multinomial probabilities. */
    const Conf mode_conf;               /*!< A subisotopologue with most probability. If not unique, one of the representatives of that class of subisotopologues. */
    const double mode_lprob;            /*!< The log-probability of the mode subisotopologue.*/
    const double mode_mass;             /*!< The mass of the mode subisotopologue.*/
    const double mode_eprob;            /*!< The probability of the mode subisotopologue.*/
    const double smallest_lprob;        /*!< The smallest-achievable log-probability in the distribution of subisotopologues. */


public:
    //! Class constructor.
    /*!
        \param _masses A table of masses of the stable isotopes of the investigated element, e.g. for C10 it is 2: C12 and C13.
        \param _probs A table of natural frequencies of the stable isotopes of the investigated element, see IUPAC at https://iupac.org/isotopesmatter/
        \param _isotopeNo Number of isotopes of a given element.
        \param _atomCnt The number of atoms of the given element, e.g. 10 for C10.
    */
    Marginal(
        const double* _masses,   // masses size = logProbs size = isotopeNo
        const double* _probs,
        int _isotopeNo,                  // No of isotope configurations.
        int _atomCnt
    );

    // Get rid of the C++ generated copy and assignment constructors.
    Marginal(Marginal& other) = delete;
    Marginal& operator= (const Marginal& other) = delete;
    
    //! Move constructor.
    Marginal(Marginal&& other);

    //! Destructor.
    virtual ~Marginal();

    //! Get the number of isotopes of the investigated element.
    inline int get_isotopeNo() const { return isotopeNo; };

    //! Get the mass of the lightest subisotopologue.
    /*! This is trivially obtained by considering all atomNo atoms to be the lightest isotope possible.*/
    double getLightestConfMass() const;

    //! Get the mass of the heaviest subisotopologue.
    /*! This is trivially obtained by considering all atomNo atoms to be the heaviest isotope possible.*/
    double getHeaviestConfMass() const;

    //! Get the log-probability of the mode subisotopologue.
    inline double getModeLProb() const { return mode_lprob; };

    //! The the mass of the mode subisotopologue.
    inline double getModeMass() const { return mode_mass; };

    //! The the probability of the mode subisotopologue.
    inline double getModeEProb() const { return mode_eprob; };

    //! The the log-probability of the lightest subisotopologue.
    inline double getSmallestLProb() const { return smallest_lprob; };


    //! Calculate the log-probability of a given subisotopologue.
    /*!
        \param conf A subisotopologue (a table of integers describing subsequent isotope-counts).
    */
    inline double logProb(Conf conf) const { return loggamma_nominator + unnormalized_logProb(conf, atom_lProbs, isotopeNo); };
};


//! The marginal distribution class (a subisotopologue).
/*!
    This is a class akin to IsoOrderedGenerator.
    It stores 
*/
class MarginalTrek : public Marginal
{
private:
    int current_count;
    const KeyHasher keyHasher;
    const ConfEqual equalizer;
    const ConfOrderMarginal orderMarginal;
    std::unordered_map<Conf,int,KeyHasher,ConfEqual> visited;
    std::priority_queue<Conf,std::vector<Conf>,ConfOrderMarginal> pq;
    Summator totalProb;
    Conf candidate;
    Allocator<int> allocator;
    std::vector<double> _conf_probs;
    std::vector<double> _conf_masses;
    std::vector<int*> _confs;

    //! Proceed to the next configuration and memoize it (as it will be surely needed).
    bool add_next_conf();

public:
    //! Move constructor: specializes the Marginal class.
    /*!
        \param tabSize The size of the table used to store configurations in the allocator.
        \param hashSize The size of the hash table used to store visited subisotopologues.
    */
    MarginalTrek(
        Marginal&& m,
        int tabSize = 1000,
        int hashSize = 1000
    );

    //! Check if the table of computed subisotopologues does not have to be extended.
    /*!
        This function checks if the idx-th most probable subisotopologue was memoized and if not, computes it and memoizes it.

        \param idx The number of the idx-th most probable subisotopologue.
    */
    inline bool probeConfigurationIdx(int idx)
    {
        while(current_count <= idx)
            if(!add_next_conf())
                return false;
        return true;
    }


    int processUntilCutoff(double cutoff);

    inline const std::vector<double>& conf_probs() const { return _conf_probs; };
    inline const std::vector<double>& conf_masses() const { return _conf_masses; };
    inline const std::vector<int*>& confs() const { return _confs; };


    virtual ~MarginalTrek();
};


//! Precalculated Marginal class
/*!
    This class serves to calculate a set of isotopologues that 
    is defined by the minimal probability threshold.

    This works faster than if you did not know the threshold.
    If you have no idea about the threshold, you would need to call us,
    to change encode the layered version of the marginal.
*/
class PrecalculatedMarginal : public Marginal
{
protected:
    std::vector<Conf> configurations;
    Conf* confs;
    unsigned int no_confs;
    double* masses;
    double* lProbs;
    double* eProbs;
    Allocator<int> allocator;
public:
    PrecalculatedMarginal(
        Marginal&& m,
	double lCutOff,
	bool sort = true,
	int tabSize = 1000,
	int hashSize = 1000
    );
    virtual ~PrecalculatedMarginal();
    inline bool inRange(unsigned int idx) const { return idx < no_confs; };
    inline const double& get_lProb(int idx) const { return lProbs[idx]; };
    inline const double& get_eProb(int idx) const { return eProbs[idx]; };
    inline const double& get_mass(int idx) const { return masses[idx]; };
    inline const double* get_lProbs_ptr() const { return lProbs; };
    inline const double* get_masses_ptr() const { return masses; };
    inline const Conf& get_conf(int idx) const { return confs[idx]; };
    inline unsigned int get_no_confs() const { return no_confs; };
};

class SyncMarginal : public PrecalculatedMarginal
{
    /*!
    Big experiment for multi-threaded version of the algorithm, do not touch.
    */
protected:
    char padding[64]; /*  padding[64]; */ // against fake-sharing cache lines...
    std::atomic<unsigned int> counter;
    char padding2[64]; /// likewise...
public:
    inline SyncMarginal(
        Marginal&& m,
        double lCutOff,
        int tabSize = 1000,
        int hashSize = 1000
    ) : PrecalculatedMarginal(
        std::move(m),
        lCutOff,
        false,
        tabSize,
        hashSize
    ), counter(0) {};


    inline unsigned int getNextConfIdx() { return counter.fetch_add(1, std::memory_order_relaxed); };
    inline unsigned int getNextConfIdxwMass(double mmin, double mmax)
    {
    	unsigned int local = counter.fetch_add(1, std::memory_order_relaxed);
	while(local < no_confs && (mmin > masses[local] || mmax < masses[local]))
	    local = counter.fetch_add(1, std::memory_order_relaxed);
	return local;
    }


};


class LayeredMarginal : public Marginal
{
    /*!
        An extendable version of the PrecalculatedMarginal,
        where you can extend the threshold.
    */
private:
    double current_threshold;
    std::vector<Conf> configurations;
    std::vector<Conf> fringe;
    Allocator<int> allocator;
    unsigned int sorted_up_to_idx;
    const ConfEqual equalizer;
    const KeyHasher keyHasher;
    const ConfOrderMarginalDescending orderMarginal;
    std::vector<double> lProbs;
    std::vector<double> eProbs;
    std::vector<double> masses;
    double* guarded_lProbs;
    const int hashSize;

public:
    LayeredMarginal(Marginal&& m, int tabSize = 1000, int hashSize = 1000);
    bool extend(double new_threshold);
    inline double get_lProb(int idx) const { return guarded_lProbs[idx]; }; // access to idx == -1 is valid and gives a guardian of +inf
    inline double get_eProb(int idx) const { return eProbs[idx]; };
    inline double get_mass(int idx) const { return masses[idx]; };
    inline const Conf& get_conf(int idx) const { return configurations[idx]; };
    inline unsigned int get_no_confs() const { return configurations.size(); };

};

} // namespace IsoSpec

